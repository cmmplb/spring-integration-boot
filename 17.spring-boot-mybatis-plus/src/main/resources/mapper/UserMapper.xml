<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.cmmplb.mybatis.plus.dao.UserMapper">

    <!--  keyColumn="id" keyProperty="id" useGeneratedKeys="true" -->

    <!-- 开启二级缓存 -->
    <cache eviction="LRU" flushInterval="108000" readOnly="false" size="1024"/>

    <!-- 声明缓存，这里3.x只需要这样配置 -->
    <!-- <cache-ref namespace="com.cmmplb.mybatis.plus.dao.UserMapper"/> -->

    <!-- 1. eviction：缓存回收策略：• 默认的是 LRU。
            LRU – 最近最少使用的：移除最长时间不被使用的对象。
            FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
            SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
            WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
        2. flushInterval：刷新间隔，单位毫秒
            默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新
        3. size：引用数目，正整数
            代表缓存最多可以存储多少个对象，太大容易导致内存溢出
        4. readOnly：只读，true/false
            true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。
            false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。
     -->

    <sql id="base_column">
        <!-- @sql select -->
        u.`id`,
        u.`name`,
        u.`sex`,
        u.`mobile`,
        u.`status`,
        u.`create_time`,
        u.`update_time`,
        u.`version`,
        u.`deleted`
        <!-- @sql from `user` u -->
    </sql>

    <sql id="base_select">
        select
        <include refid="base_column"/>
        from `user` u
    </sql>

    <!-- 如果一条语句每次都需要最新的数据，就意味着每次都需要从数据库中查询数据，可以把这个属性设置为false -->
    <select id="selectByPaged" resultType="com.cmmplb.mybatis.plus.entity.User" useCache="false">
        select
        <include refid="base_column"/>
        from `user` u
    </select>

    <select id="getByPagedTotal" resultType="java.lang.Long">
        select count(1)
        from `user`
    </select>

    <select id="getByList" resultType="com.cmmplb.mybatis.plus.entity.User">
        select *
        from `user`
        limit #{start},#{size}
    </select>

    <resultMap id="info_map" type="com.cmmplb.mybatis.plus.vo.UserInfoVO">
        <result column="id" property="id"/>
        <!-- 一对一子查询 -->
        <association property="userInfo" javaType="com.cmmplb.mybatis.plus.entity.UserInfo" column="{id = id}"
                     select="com.cmmplb.mybatis.plus.dao.UserInfoMapper.selectById"/>
    </resultMap>

    <!-- 如果一条语句每次都需要最新的数据，就意味着每次都需要从数据库中查询数据，可以把这个属性设置为false -->
    <select id="selectUserInfoById" resultMap="info_map" useCache="false">
        <include refid="base_select"/>
        where u.id = #{id}
    </select>

    <resultMap id="sub_query_map" type="com.cmmplb.mybatis.plus.vo.UserInfoVO" extends="info_map">
        <!-- 一对多子查询 -->
        <collection property="tagList" javaType="java.util.List" ofType="com.cmmplb.mybatis.plus.entity.Tag"
                    column="{userId = id}" select="com.cmmplb.mybatis.plus.dao.TagMapper.selectByUserId"/>
    </resultMap>

    <select id="selectTestOneMany2SubQuery" resultMap="sub_query_map">
        <include refid="base_select"/>
        where u.id = #{id}
    </select>

    <resultMap id="field_mapping_map" type="com.cmmplb.mybatis.plus.vo.UserInfoVO" extends="info_map">
        <!-- 字段映射 -->
        <collection property="tagList" ofType="com.cmmplb.mybatis.plus.entity.Tag">
            <id column="tag_id" property="id"/>
            <result column="tag_name" property="name"/>
            <result column="tag_create_by" property="createBy"/>
            <result column="tag_create_time" property="createTime"/>
            <result column="tag_update_by" property="updateBy"/>
            <result column="tag_update_time" property="updateTime"/>
            <result column="tag_deleted" property="deleted"/>
        </collection>
    </resultMap>

    <select id="selectTestOneMany2FieldMapping" resultMap="field_mapping_map">
        select
        <include refid="base_column"/>
        ,t.`id`          `tag_id`
        ,t.`name`        `tag_name`
        ,t.`create_by`   `tag_create_by`
        ,t.`create_time` `tag_create_time`
        ,t.`update_by`   `tag_update_by`
        ,t.`update_time` `tag_update_time`
        ,t.`deleted`     `tag_deleted`
        from `user` u
        left join `user_tag` ut on u.`id` = ut.`user_id`
        left join `tag` t on t.`id` = ut.`tag_id` and t.`deleted` = 0
        where u.`id` = #{id}
    </select>
</mapper>